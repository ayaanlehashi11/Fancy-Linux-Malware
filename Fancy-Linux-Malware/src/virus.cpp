/* main.cpp
 *
 *  Created on: Apr 22, 2023
 *      Author: ayaanle
 */
 
 
#include <iostream>
#include <boost/filesystem.hpp>
#include <assert.h>
#include <chrono>
#include <vector>
#include <fstream>
#include <ctime>
#include <regex>
#include <errno.h>
#include "server.h"
#include "sysinfo.h"
#define GNOME_TERMINAL_CMD      "gnome-terminal -- "
#define GNOME_TERMINAL_GEO      "gnome-terminal --geometry"

#endif

using namespace std;
using namespace boost::filesystem;
class Startup
{
public:
    constexpr explicit Startup();
    static uint time_steps(uint8_t) ;
    friend string required_file(path& path);
    friend const struct system_info* sys_info(struct system_info* sys_info);
    friend bool check_files(path p);
    constexpr inline void init_malware(string program );
public:
    bool file_exists = 0;
    signed long int file_size;
};
inline uint Startup::time_steps(uint8_t num)
{
    auto count = std::chrono::seconds(num).count();
    return count;
}

 string extract_info(string str)
{
   str.substr(0 , 11);
   regex rgx;
   regex::iterator it;
}

string required_file(path p , string filename)
{
    path p;
    p = path(filename);
    vector<path>::iterator it;
    int counter = 0;

    try{
        if(exists(p) and p.has_filename() and p.has_extension())
    {
        if(is_regular_file(p))
        {
            // the path supplied is a regular file
            switch(p.filename())
            {
                case "stat":
                break;
            }
        }
        else if(is_directory(p))
        {
            vector<path>vec;
            for(auto &&x : directory_iterator(p))
                vec.push_back(x.path());
            sort(vec.begin() , vec.end());
            for(it = vec.begin(); it != vec.end(); ++it)
            {
                *it;
            }
        }
        
    }
    }
    catch(const filesystem_error& err)
    {
        cout << ex.what() << endl;
    }
}
constexpr void disk_struct::file_stat(path* path)
{

    path->
}

// you first need to check the required files for the prank
bool check_files(string filename)
{
    
    // else if(!exists(p)){
        
    // }

}
constexpr inline void init_malware()
{
   int counter = 0;
   for(;;)
        {
            while(counter != Startup::time_steps(2))
            {
               system("gnome-terminal -- echo hacked");
               system("paplay drip.ogg") or
                system("paplay /usr/share/sounds/gnome/default/alerts/drip.ogg");
               counter++;
            }
            counter -= Startup::time_steps(2);
        }
}

const struct memo_struct* memory_leaker::memory_info(const struct memory_struct* mem_info)
{
    
}
volatile signed long memory_leaker::leaker_init()
{
    
}
int main(int argc , char* argv[])
{
    
    disk_struct ds;
    string str;
    vector<string>paths = {"/proc/cpuinfo" ,
                           "/proc/memstat" ,
                           "/proc/stat"};  
    fstream strm;
    vector<string>::iterator it;                        
    for(it = paths.begin();it!=paths.end();++it)
    {
       // accessing the most important hardware config infos
      str = *it;
      strm.open(str, ios_base::in);
      if (!strm.is_open() and ) {
         cout << "Open file failed" << endl;
         return 1;
    }
    char c;

    while (!strm.eof()) {
        strm.get(c);
        cout << c;
    }
    }
    cout << str << endl;

    strm.close();
    Startup startup = Startup();
    return 0;
}


